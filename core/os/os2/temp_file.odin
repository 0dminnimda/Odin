package os2

import "base:intrinsics"
import "base:runtime"

@(private="file")
MAX_ATTEMPTS :: 1<<13 // Should be enough for everyone, right?

// Creates a new temperatory file in the directory `dir`.
//
// Opens the file for reading and writing, with 0o666 permissions, and returns the new `^File`.
// The filename is generated by taking a pattern, and adding a randomized string to the end.
// If the pattern includes an "*", the randm string replaces the last "*".
// If `dir` is an empty tring, `temp_directory()` will be used.
//
// The caller must `close` the file once finished with.
create_temp_file :: proc(dir, pattern: string) -> (f: ^File, err: Error) {
	TEMP_ALLOCATOR_GUARD()
	dir := dir if dir != "" else temp_directory(temp_allocator()) or_return
	prefix, suffix := _prefix_and_suffix(pattern) or_return
	prefix = temp_join_path(dir, prefix)

	rand_buf: [32]byte
	name_buf := make([]byte, len(prefix)+len(rand_buf)+len(suffix), temp_allocator())

	attempts := 0
	for {
		name := concatenate_strings_from_buffer(name_buf[:], prefix, random_string(rand_buf[:]), suffix)
		f, err = open(name, {.Read, .Write, .Create, .Excl}, File_Mode(0o666))
		if err == .Exist {
			close(f)
			attempts += 1
			if attempts < MAX_ATTEMPTS {
				continue
			}
			return nil, err
		}
		return f, err
	}
}

mkdir_temp :: make_directory_temp
// Creates a new temporary directory in the directory `dir`, and returns the path of the new directory.
//
// The directory name is generated by taking a pattern, and adding a randomized string to the end.
// If the pattern includes an "*", the randm string replaces the last "*".
// If `dir` is an empty tring, `temp_directory()` will be used.
make_directory_temp :: proc(dir, pattern: string, allocator: runtime.Allocator) -> (temp_path: string, err: Error) {
	TEMP_ALLOCATOR_GUARD()
	dir := dir if dir != "" else temp_directory(temp_allocator()) or_return
	prefix, suffix := _prefix_and_suffix(pattern) or_return
	prefix = temp_join_path(dir, prefix)

	rand_buf: [32]byte
	name_buf := make([]byte, len(prefix)+len(rand_buf)+len(suffix), temp_allocator())

	attempts := 0
	for {
		name := concatenate_strings_from_buffer(name_buf[:], prefix, random_string(rand_buf[:]), suffix)
		err = make_directory(name, 0o700)
		if err == nil {
			return clone_string(name, allocator), nil
		}
		if err == .Exist {
			attempts += 1
			if attempts < MAX_ATTEMPTS {
				continue
			}
			return "", err
		}
		if err == .Not_Exist {
			if _, serr := stat(dir, temp_allocator()); serr == .Not_Exist {
				return "", serr
			}
		}
		return "", err
	}

}

temp_dir :: temp_directory
temp_directory :: proc(allocator: runtime.Allocator) -> (string, Error) {
	return _temp_dir(allocator)
}


// Splits pattern by the last wildcard "*", if it exists, and returns the prefix and suffix
// parts which are split by the last "*"
@(private)
_prefix_and_suffix :: proc(pattern: string) -> (prefix, suffix: string, err: Error) {
	for i in 0..<len(pattern) {
		if is_path_separator(pattern[i]) {
			err = .Pattern_Has_Separator
			return
		}
	}
	prefix = pattern
	for i := len(pattern)-1; i >= 0; i -= 1 {
		if pattern[i] == '*' {
			prefix, suffix = pattern[:i], pattern[i+1:]
			break
		}
	}
	return
}

@(private)
clone_string :: proc(s: string, allocator: runtime.Allocator) -> string {
	buf := make([]byte, len(s), allocator)
	copy(buf, s)
	return string(buf)
}


@(private)
concatenate_strings_from_buffer :: proc(buf: []byte, strings: ..string) -> string {
	n := 0
	for s in strings {
		(n < len(buf)) or_break
		n += copy(buf[n:], s)
	}
	n = min(len(buf), n)
	return string(buf[:n])
}



@(private)
temp_join_path :: proc(dir, name: string) -> string {
	concat :: proc(strings: ..string) -> string {
		n := 0
		for s in strings {
			n += len(s)
		}
		buf := make([]byte, n)
		n = 0
		for s in strings {
			n += copy(buf[n:], s)
		}
		return string(buf)
	}

	if len(dir) > 0 && is_path_separator(dir[len(dir)-1]) {
		return concat(dir, name)
	}

	return concat(dir, Path_Separator_String, name)
}


@(private="file")
random_string_seed: [2]u64

@(init, private="file")
init_random_string_seed :: proc() {
	seed := u64(intrinsics.read_cycle_counter())
	s := &random_string_seed
	s[0] = 0
	s[1] = (seed << 1) | 1
	_ = next_random(s)
	s[1] += seed
	_ = next_random(s)
}

@(private="file")
next_random :: proc(r: ^[2]u64) -> u64 {
	old_state := r[0]
	r[0] = old_state * 6364136223846793005 + (r[1]|1)
	xor_shifted := (((old_state >> 59) + 5) ~ old_state) * 12605985483714917081
	rot := (old_state >> 59)
	return (xor_shifted >> rot) | (xor_shifted << ((-rot) & 63))
}

@(private="file")
random_string :: proc(buf: []byte) -> string {
	@static digits := "0123456789"

	u := next_random(&random_string_seed)

	b :: 10
	i := len(buf)
	for u >= b {
		i -= 1
		buf[i] = digits[u % b]
		u /= b
	}
	i -= 1
	buf[i] = digits[u % b]
	return string(buf[i:])
}
